<div id="sect_title_img_3_9"></div>

<div id="sect_title_text"></div>

# 座標変換を活用する②

<div id="preface"></div>

###### [3-8節](08_Use_Coordinate_Transformation_1.md) では3D空間の座標からリージョン座標への座標変換を bpy_extra モジュールを使って行う方法を説明しました。本節では、その反対であるリージョン座標から3D空間の座標へ変換する方法を説明します。また本節の最後では、bpy_extra モジュールを使わずとも3D空間からリージョン座標へ座標変換可能であることを示します。


## 作成するアドオンの仕様

* マウスカーソルの位置に向けて発した直線（レイ）と交差するオブジェクト名を選択状態にし、交差していないオブジェクトは非選択状態にする


## アドオンを作成する

[1-5節](../chapter_01/05_Install_own_Add-on.md) を参考にして以下のソースコードをテキスト・エディタに入力し、ファイル名 ```sample_3-9.py``` として保存してください。

[import](../../sample/src/chapter_03/sample_3-9.py)

## アドオンを使用する

### アドオンを有効化する

[1-5節](../chapter_01/05_Install_own_Add-on.md) を参考に作成したアドオンを有効化すると、コンソールウィンドウに文字列が出力されます。

```sh
サンプル3-9: アドオン「サンプル3-9」が有効化されました。
```


|また、*3Dビュー* エリアのプロパティパネルに *マウスオーバでオブジェクト選択* が追加されていることを確認します。|![3-9節 アドオン有効化](https://dl.dropboxusercontent.com/s/ilcmmt4j5vfm5tg/enable_add-on.png "3-9節 アドオン有効化")|
|---|---|

### アドオンの機能を使用する

以下の手順に従って、作成したアドオンの機能を使ってみます。

<div id="process_title"></div>

##### Work

<div id="process"></div>

|<div id="box">1</div>|*3Dビュー* エリアのプロパティパネルに追加された *マウスオーバでオブジェクト選択* の *開始* ボタンをクリックします。|![3-9節 アドオンの使用 手順1](https://dl.dropboxusercontent.com/s/n4mv912p5mi2im6/use_add-on_1.png "3-9節 アドオンの使用 手順1")|
|---|---|---|

<div id="process_sep"></div>

---

<div id="process"></div>

|<div id="box">2</div>|*オブジェクトモード* の状態マウスカーソルがオブジェクトに重なると、重なったオブジェクトが選択状態になります。|![3-9節 アドオンの使用 手順2](https://dl.dropboxusercontent.com/s/z4cv2b1wxcdws10/use_add-on_2.png "3-9節 アドオンの使用 手順2")|
|---|---|---|

<div id="process_sep"></div>

---


<div id="process"></div>

|<div id="box">3</div>|*マウスオーバでオブジェクト選択* の *終了* ボタンをクリックし、マウスカーソルがオブジェクトに重なっても選択されないようにします。|![3-9節 アドオンの使用 手順3](https://dl.dropboxusercontent.com/s/xg5xpb1vcp6450b/use_add-on_3.png "3-9節 アドオンの使用 手順3")|
|---|---|---|

<div id="process_sep"></div>

---


<div id="process_start_end"></div>

---


### アドオンを無効化する

[1-5節](../chapter_01/05_Install_own_Add-on.md) を参考に有効化したアドオンを無効化すると、コンソールウィンドウに文字列が出力されます。

```sh
サンプル3-9: アドオン「サンプル3-9」が無効化されました。
```


## ソースコードの解説

[3-8節](08_Use_Coordinate_Transformation_1.md) と同様、本節でも座標変換に関する部分に絞って解説します。

### マウスカーソルの位置に向けて発したレイと交差するオブジェクトを選択する

マウスカーソルの位置に向けて発したレイと交差するオブジェクトを選択するための手順を次に示します。

1. マウスカーソルのリージョン座標を取得する
2. リージョン座標から、レイの向きと発生源の座標を求める
3. レイの始点と終点の座標を求める
4. レイと *3Dビュー* エリアに配置されているオブジェクトとの交差判定を行う
5. レイと交差したオブジェクトを選択する

上記の処理は、全て ```SelectObjectOnMouseover``` クラスの ```modal()``` メソッドで行っています。


#### 1. マウスカーソルのリージョン座標を取得する

マウスカーソルのリージョン座標を取得するためのコードを次に示します。マウスカーソルのリージョン座標は、```mouse_region_x``` （X座標）と ```mouse_region_y``` （Y座標）で取得することができます。

[import:"get_mouse_region_coord", unindent:"true"](../../sample_raw/src/chapter_03/sample_3-9.py)


#### 2. リージョン座標から、レイの向きと発生源の座標を求める

1で取得したマウスカーソルのリージョン座標からレイの向きと発生源の座標を求めます。[3-8節](08_Use_Coordinate_Transformation_1.md) で *3Dビュー* エリアの3D空間の座標からリージョン座標へ座標する場合と同様、この座標変換を1から実装すると大変です。そこで本節のサンプルでも ```bpy_extra``` モジュールの ```view3d_utils``` サブモジュールを利用することにします。リージョン座標から、レイの向きと発生源の座標を求めるためのコードを以下に示します。

[import:"calc_ray_dir_and_orig", unindent:"true"](../../sample_raw/src/chapter_03/sample_3-9.py)

レイの発生源は、*3Dビュー* エリアの3D空間を映し出しているカメラの座標（視点）となるため、```view3d_utils.region_2d_to_origin_3d()``` 関数を使って取得することができます。一方レイの向きは、視点からマウスカーソルのリージョン座標を *3Dビュー* の3D空間座標に変換した座標の点への向きとなるため、```view3d_utils.region_2d_to_vector_3d()``` 関数を使って取得します。```view3d_utils.region_2d_to_vector_3d()``` 関数と ```view3d_utils.region_2d_to_origin_3d()``` 関数の引数は次に示すように、共に同じ引数を受け取ります。

|引数|意味|
|---|---|
|第1引数|座標変換対象のリージョン|
|第2引数|座標変換対象の3Dリージョンデータ|
|第3引数|リージョン座標|

[3-8節](08_Use_Coordinate_Transformation_1.md) と同様、引数に指定するデータは ```get_region_space``` スタティックメソッドで取得します。


#### 3. レイの始点と終点の座標を求める

4で使用する ```ray_cast``` 関数は、引数にレイの始点と終点を指定する必要があります。このため次のコードにより、2で取得したレイの向きと発生源の座標からレイの視点と終点を求めます。

[import:"calc_ray_start_end", unindent:"true"](../../sample_raw/src/chapter_03/sample_3-9.py)

レイの始点はレイの発生源と同じです。一方レイの終点は、レイの発生源からレイの方向に伸ばした線上に設定します。本節では、発生源から距離が2000離れたところに終点を設定しています。このため、距離がレイの発生源から2000以上離れたオブジェクトは交差判定の対象外となります。

なお ```ray_cast()``` によるレイとオブジェクトの交差判定は、**オブジェクトのローカル座標で行います** 。このため、レイの始点と終点もオブジェクトのローカル座標に座標変換する必要があります。本節のサンプルでは、オブジェクトの位置を原点に移動するようにレイの始点と終点の座標を移動し、```ray_cast()``` の引数に指定しました。


#### 4. レイと3Dビューエリアに配置されているオブジェクトとの交差判定を行う

レイとオブジェクトの交差判定は、```ray_cast()``` 関数で行うことができます。しかし ```ray_cast()``` 関数には、*オブジェクトモード* 以外で実行できないという制限があります。本節のサンプルでは、 *オブジェクトモード* 時のみオブジェクトの選択を可能とする使用のため問題がありませんが、```ray_cast()``` を使うときには気を付けておきましょう。

[import:"check_intersection", unindent:"true"](../../sample_raw/src/chapter_03/sample_3-9.py)

レイと交差したオブジェクトは、メンバ変数 ```intersected_objs``` に保存します。レイとオブジェクトが交差したことは、```ray_cast()``` 関数の戻り値で確認します。```ray_cast()``` 関数の戻り値は次に示すタプル型の値です。本節のサンプルでは ```ray_cast()``` の戻り値の第3要素が ```-1``` 以外の場合にレイが交差したと判定します。

|戻り値|意味|
|---|---|
|第1要素|レイが交差した座標|
|第2要素|レイが交差した面の法線|
|第3要素|レイが交差した面のインデックス（交差した面が存在しない場合は-1）|


本節のサンプルでは ```ray_cast()``` の処理を ```try``` ブロックで囲み、例外処理を実装しています。これはメッシュ型のオブジェクトを作成した時に、作成タイミングの問題で ```ray_cast()``` の処理を実行できない場合に例外が発生し、処理が中断してしまうことを避けるためです。この問題を避けるために ```ray_cast()``` 関数を実行するオブジェクトをメッシュ型に絞っていますが、ここまで対処してもタイミングによって時々例外が発生してしまうことから、安全面を重視して例外処理を追加しています。


<div id="tips"></div>

他のAPIにも言えることですが、ray_cast()メソッドはBlenderのバージョン間で外部仕様が大きく変わっているようです。本書の対象とするBlenderのバージョン2.75では、戻り値はレイが交差した座標・面の法線・面のインデックスの3個でしたが、2.77では第1引数にレイとオブジェクトとの交差結果（交差した場合はTrue）に続いて交差した座標・面の法線・面のインデックスなど6個の要素から構成されるタプルが戻り値になります。また引数についても、2.75ではレイの始点と終点の2個を指定しますが、2.77ではレイの原点と方向および長さの3個の引数を指定します。  
このようにBlenderのバージョンによってAPIの外部仕様が変わることはよくあることで、アドオンのバグ報告の大半がBlender本体のバージョンに関係したものとなっています。[4-1節](../chapter_04/01_Research_official_Blender_API_for_Add-on.md) を参考にして、アドオンの開発を行なっているBlenderのバージョンのAPIの仕様を確認するよう心がけ、[2-1節](../chapter_02/01_Basic_of_Add-on_Development.md) で説明したサポート対象のBlenderのバージョンを適切に設定しましょう。  
なお、Blenderのバージョン2.77で正しく動作するコードの一部を次に示します。


```python
# マウスカーソルの位置に向けて発したレイの方向を求める
ray_dir = view3d_utils.region_2d_to_vector_3d(
    region,
    space.region_3d,
    mv)
# マウスカーソルの位置に向けて発したレイの発生源を求める
ray_orig = view3d_utils.region_2d_to_origin_3d(
    region,
    space.region_3d,
    mv)
# レイの始点
start = ray_orig
# レイの終点（線分の長さは2000とした）
end = ray_orig + ray_dir * 2000
# カメラやライトなど、メッシュ型ではないオブジェクトは除く
objs = [o for o in bpy.data.objects if o.type == 'MESH']
self.intersected_objs = []
for o in objs:
    try:
        # レイとオブジェクトの交差判定
        mwi = o.matrix_world.inverted()
        mwi_start = mwi * start
        mwi_end = mwi * end
        dir_ = mwi_end - mwi_start
        dir_.normalize()
        result = o.ray_cast(mwi * start, dir_, 2000)
        # オブジェクトとレイが交差した場合は交差した面のインデックス、交差しない場合は-1が返ってくる
        if result[0]:
            self.intersected_objs.append(o)
    # メッシュタイプのオブジェクトが作られているが、ray_cast対象の面が存在しない場合
    except RuntimeError as e:
        print("サンプル3-9: オブジェクト生成タイミングの問題により、例外エラー「レイキャスト可能なデータなし」が発生")
```


#### 5. レイと交差したオブジェクトを選択する

最後に、```intersected_objs``` メンバ変数に例と交差したオブジェクトが格納されていることを利用し、次の処理でレイと交差したオブジェクトを選択します。

[import:"select_object", unindent:"true"](../../sample_raw/src/chapter_03/sample_3-9.py)


## 自力で座標変換を行う

本節の冒頭で、APIを使わずとも自力で座標変換が可能であると書きました。ここでは、```bpy_extras``` モジュールの ```view3d_utils``` を利用せずにローカル座標からリージョン座標へ変換する方法を説明します。

文章だけの説明ではわかりづらいと思うので、選択中の頂点のローカル座標からリージョン座標へ変換するPythonスクリプト ```transform_wo_view3d_utils.py``` を作りました。実際に本スクリプトの動作確認を行う時は、スクリプトの内容を記載した後に *テキストエディタ* エリアのメニューから *テキスト* > *スクリプト実行* を実行します。

[import](../../sample/src/chapter_03/transform_wo_view3d_utils.py)

リージョンやスペースの取得を ```get_region_and_space()``` 関数で行なっていますが、仮に指定したスペースが存在しなかった場合は座標変換することができなくなるため、何もせずにプログラムの実行を終了します。

本節の冒頭でも書きましたが、ローカル座標からリージョン座標へ座標変換するためには以下の計算を行う必要があります。

```sh
リージョン座標 = ビューポート変換行列 × 射影変換行列 × ビュー変換行列 × グローバル座標変換行列 × ローカル座標
```

本節のサンプルではリージョンとスペース取得後に、以下の順番で座標変換を行ないます。

1. 選択中の頂点のローカル座標を取得する
2. ローカル座標からグローバル座標へ変換する
3. グローバル座標から射影座標へ変換する
4. 射影座標からリージョン座標へ変換する


### 1. 選択中の頂点のローカル座標を取得する

選択中の頂点のローカル座標は、[3-1節](01_Handle_Mouse_Click_Event.md) で説明した ```bmesh``` モジュールを使って取得します。

[import:"get_local_coord", unindent:"true"](../../sample_raw/src/chapter_03/transform_wo_view3d_utils.py)

メッシュの頂点情報のリストは ```bm.verts``` に保存され、各頂点要素の ```select``` メンバ変数が ```True``` の時に頂点が選択されていると判断できます。頂点のローカル座標は、各頂点要素の ```co``` メンバ変数に保存されています。


### 2. ローカル座標からグローバル座標へ変換する

ローカル座標からグローバル座標への変換は、次の計算を行います。

```sh
グローバル座標 = グローバル座標変換行列 × ローカル座標
```

上記の計算をコードにすると次のようになります。

[import:"transform_local_to_global", unindent:"true"](../../sample_raw/src/chapter_03/transform_wo_view3d_utils.py)

グローバル座標変換行列は ```obj.matrix_world``` で取得することができ、グローバル座標変換行列に1で取得したローカル座標を掛けることでグローバル座標へ変換することができます。


### 3. グローバル座標から射影座標へ変換する

グローバル座標から射影座標への変換は、次の計算で行います。

```sh
射影座標 = 射影変換行列 × ビュー変換行列 × グローバル座標
```

ビュー変換行列と射影変換行列は、それぞれ ```space.region_3d.view_matrix``` と ```space.region_3d.window_matrix``` で取得することができます。しかしBlenderでは、射影変換行列とビュー変換行列を掛けた透視変換行列 ```space.region_3d.perspective_matrix``` を利用することができます。従って、上記の座標変換をコードにすると次のようになります。

[import:"transform_global_to_pers", unindent:"true"](../../sample_raw/src/chapter_03/transform_wo_view3d_utils.py)


### 4. 射影座標からリージョン座標へ変換する

最後に射影座標からリージョン座標へ変換します。変換は次の計算で行います。

```sh
リージョン座標 = ビューポート変換行列 × 射影座標
```

Blenderは、適用されているビューポート変換行列を参照するためのAPIを提供していません。このため、ビューポート変換を自力で行う必要があります。ビューポート変換を行うために必要な情報は、リージョンの幅と高さです。リージョンの幅と高さは ```get_region_and_space()``` 関数で取得したリージョン情報 ```region``` から取得することができます。これらの情報と ```viewport_transform()``` 関数を用いて、ビューポート変換を行います。

[import:"viewport_transform", unindent:"true"](../../sample_raw/src/chapter_03/transform_wo_view3d_utils.py)


上記の ```viewport_transform()``` 関数を用いて、射影座標からリージョン座標へ変換するためのコードを以下に示します。

[import:"transform_pers_to_region", unindent:"true"](../../sample_raw/src/chapter_03/transform_wo_view3d_utils.py)


### view3d_utilsを使った場合との比較

最後に、自力で行った座標変換と ```view3d_utils``` を利用した場合と結果が一致することを確認します。自力で座標変換を行うスクリプトは ```transform_wo_view3d_utils.py``` ですが、```view3d_utils``` を利用して座標変換する場合のスクリプトを ```transform_w_view3d_utils.py``` として作成しました。

[import](../../sample/src/chapter_03/transform_w_view3d_utils.py)

ここで、```transform_wo_view3d_utils.py``` と ```transform_w_view3d_utils.py``` の2つのスクリプトを *テキストエディタ* エリアに入力し、メニューから *テキスト* > *スクリプト実行* を実行してコンソールウィンドウの出力結果を見てみましょう。

最初に、2つの頂点を選択した状態における ```transform_wo_view3d_utils.py``` の実行結果を次に示します。

```sh
==========
local: Vector((1.0, 0.9999999403953552, -1.0, 1.0))
global: Vector((5.755486965179443, -2.95807147026062, -1.0, 1.0))
perspective: Vector((-0.35493502020835876, -4.155908107757568, 9.453906059265137, 9.651995658874512))
region: Vector((466.6833801269531, 274.4628601074219))
==========
local: Vector((0.9999993443489075, -1.0000005960464478, 1.0, 1.0))
global: Vector((5.755486488342285, -4.958072185516357, 1.0, 1.0))
perspective: Vector((-2.3789007663726807, -2.613635301589966, 7.838695526123047, 8.037108421325684))
region: Vector((341.093017578125, 325.25555419921875))
```

同様の条件で ```transform_w_view3d_utils.py``` を実行した時の結果を次に示します。```region:``` を見ると、両者の実行結果が一致していることが確認できると思います。

```sh
==========
local: Vector((1.0, 0.9999999403953552, -1.0))
region: Vector((466.6833801269531, 274.4628601074219))
==========
local: Vector((0.9999993443489075, -1.0000005960464478, 1.0))
region: Vector((341.093017578125, 325.25555419921875))
```


## まとめ

本節では、```view3d_utils``` サブモジュールを使ってリージョン座標から *3Dビュー* 上の座標へ変換する方法を説明しました。[3-8節](08_Use_Coordinate_Transformation_1.md) と2節に渡り ```view3d_utils``` サブモジュールを使った座標変換の方法を説明しましたので、ここで ```view3d_utils``` が提供する座標変換のAPI一覧についてまとめます。

|API|概要|
|---|---|
|```view3d_utils.region_2d_to_origin_3d()```|リージョンを映し出すカメラの位置を取得する|
|```view3d_utils.region_2d_to_vector_3d()```|リージョンを映し出すカメラの位置から、指定されたリージョン座標へ発するレイの方向を3Dベクトルで取得する|
|```view3d_utils.region_2d_to_location_3d()```|指定されたリージョン座標を、3D空間の座標へ変換する|
|```view3d_utils.location_3d_to_region_2d()```|指定した3D空間の座標を、リージョン座標へ変換する|


サンプルのアドオンでは、```ray_cast()``` 関数を使ったレイとオブジェクトの交差判定も行いました。```ray_cast()``` は非常に便利な関数で、交差した面や位置も取得することができます。例えば、マウスでクリックした時にマウスカーソルの位置に穴を開けたり、マウスカーソルが重なっている面を強調表示といった処理も ```ray_cast()``` 関数を使って実装することができると思います。

本節の最後では、```view3d_utils``` サブモジュールが内部で行っている座標変換について具体的に理解したい方向けに、自力でローカル座標からリージョン座標へ変換する方法する方法を解説しました。アドオンを作るだけであれば理解する必要がない内容ですが、Blenderがどのように座標変換を行なっているかを理解することはAPIを深く知るきっかけになるため、余力のある方は目を通しておきましょう。また、解説するために自力で座標変換を行うスクリプトを紹介しましたが、細かい最適化やエラー処理は省いています。座標変換さえ行えれば十分という方は、素直に ```view3d_utils``` のAPIを利用するようにしましょう。


<div id="point"></div>

### ポイント

<div id="point_item"></div>


* ```ray_cast()``` 関数を使用するとレイとオブジェクトの交差判定を行うことができ、交差位置や交差した面を取得することができる
* ```view3d_utils``` を使わずとも、ローカル座標からリージョン座標へ変換することは可能である
